language: java
os: linux
dist: bionic

jobs:
  include:
    - stage: Native library compilation
      name: Linux (x86/ARM/PPC) and Windows
      jdk: openjdk8

      install:
        - sudo make -C src/main/c crosstools
      script:
        - make -C src/main/c clean-linux clean-windows
        - make -C src/main/c -j linux windows

      addons:
        apt:
          update: true
          packages:
            # The “crostools” Make target installs the necessary packages.

        artifacts:
          paths:
            # git ls-files includes files which have been staged for deletion,
            # so that's not terribly useful.
            #
            # Builds should be repeatable (i.e., for the same compiler and
            # source versions, the resulting library will be byte-for-byte
            # identical), so we want to do artifact archival based on the git
            # status. That way, the archive will only contain unique artifacts.
            - "$(git status --porcelain src/main/c/resources/native | grep -v '^ D' | cut -c 4- | tr '\n' ':')"
          target_paths:
            - /$TRAVIS_REPO_SLUG/$TRAVIS_BUILD_NUMBER

    - name: macOS
      os: osx
      # The XCode 9.3 image is the one recommended for use with JDK 1.8.
      osx_image: xcode9.3
      # Travis doesn't support switching JDKs in macOS images, and fails with
      # an obscure error if the “jdk” property is set:
      # https://travis-ci.community/t/issue-fail-to-build-jdk8-on-osx-using-xcode9-3-image/1294
      # Unfortunately, this will occur even when the “jdk” property is set as a
      # top-level default. And setting the property here to empty or “null”
      # does not unset the default value. So the JDK must be explicitly
      # specified for all other jobs which need it in order to leave it
      # explicitly blank here.
      jdk:

      install:
      script:
        - make -C src/main/c clean-osx
        - make -C src/main/c -j osx

      addons:
        artifacts:
          paths:
            - "$(git status --porcelain src/main/c/resources/native | grep -v '^ D' | cut -c 4- | tr '\n' ':')"
          target_paths:
            - /$TRAVIS_REPO_SLUG/$TRAVIS_BUILD_NUMBER

    - name: FreeBSD
      # Docker use based on https://stackoverflow.com/a/41940240/640170.
      services:
        - docker
      before_install:
        - docker pull empterdose/freebsd-cross-build:9.3
        - >
          docker run --interactive \
                     --tty \
                     --detach \
                     --user $(id --user):$(id --group) \
                     --name build \
                     --env JAVA_HOME=$JAVA_HOME \
                     --volume $(pwd)/src/main/c:/workdir \
                     --volume $JAVA_HOME:$JAVA_HOME:ro \
                     empterdose/freebsd-cross-build:9.3

      install:
        # This feels extremely dirty, but the only native header we care about
        # is `jni_md.h`, and it is exactly identical between Linux and FreeBSD
        # (at least in OpenJDK 8).
        #
        # Note that we're modifying the Java installation on the build host.
        # The effect will be seen in the container, because the Java
        # installation directory is bind-mounted into it. We do this to avoid
        # wasting time installing Java inside the container.
        - sudo ln -s $JAVA_HOME/include/linux $JAVA_HOME/include/freebsd
      script:
        - docker exec build make clean-freebsd
        - docker exec build settarget i386-freebsd9 make -j freebsd32
        - docker exec build settarget x86_64-freebsd9 make -j freebsd64

      addons:
        artifacts:
          paths:
            - "$(git status --porcelain src/main/c/resources/native | grep -v '^ D' | cut -c 4- | tr '\n' ':')"
          target_paths:
            - /$TRAVIS_REPO_SLUG/$TRAVIS_BUILD_NUMBER

    - stage: Java library compilation
      name: Java
      jdk: openjdk8

      # If any of the prior jobs produced new native libraries, this will pull
      # them into the current source tree so they get included in the JAR.
      before_install:
        - >
          if [ -n "$ARTIFACTS_REGION" ] && [ -n "$ARTIFACTS_BUCKET" ];
          then
              aws s3 cp --recursive \
                        --no-sign-request \
                        --region $ARTIFACTS_REGION \
                        s3://$ARTIFACTS_BUCKET/$TRAVIS_REPO_SLUG/$TRAVIS_BUILD_NUMBER/src \
                        src;
          else
              echo "Artifact region and bucket not configured; skipping downloading artifacts from preceding jobs." 1>&2;
          fi

      addons:
        apt:
          update: true
          packages:
            - awscli

        artifacts:
          paths:
            - "$(git ls-files -o build/libs | tr '\n' ':')"
          target_paths:
            - /$TRAVIS_REPO_SLUG/$TRAVIS_BUILD_NUMBER
